function startRecording() {
  navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then(stream => {
    mediaStream = stream;
    videoPreview.srcObject = stream;

    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    const possibleTypes = isSafari
      ? ['video/quicktime']
      : [
          'video/webm;codecs=vp9,opus',
          'video/webm;codecs=vp8,opus',
          'video/mp4;codecs=avc1',
          'video/quicktime'
        ];

    let selectedType = possibleTypes.find(type => MediaRecorder.isTypeSupported(type));
    const options = selectedType ? { mimeType: selectedType } : undefined;

    try {
      mediaRecorder = new MediaRecorder(stream, options);
    } catch (e) {
      console.error("Failed to initialize MediaRecorder with type:", selectedType, e);
      statusDisplay.textContent = "Recording not supported in this browser.";
      return;
    }

    chunks = [];

    mediaRecorder.ondataavailable = e => chunks.push(e.data);
    mediaRecorder.onstop = () => {
      const blob = new Blob(chunks, { type: selectedType || 'video/webm' });
      const url = URL.createObjectURL(blob);
      downloadLink.href = url;

      if (selectedType && selectedType.includes('mp4')) {
        downloadLink.download = 'recording.mp4';
      } else if (selectedType && selectedType.includes('quicktime')) {
        downloadLink.download = 'recording.mov';
      } else {
        downloadLink.download = 'recording.webm';
      }

      downloadLink.style.display = 'inline';
      stopButton.style.display = 'none';
      stream.getTracks().forEach(track => track.stop());
      statusDisplay.textContent = "Recording finished!";
      document.getElementById('recordingCountdown').textContent = "";
    };

    mediaRecorder.start();
    statusDisplay.textContent = "Recording started...";
    recordingCount++;

    if (recordingCount >= MAX_RECORDINGS) disableStartButton();
    stopButton.style.display = 'inline';

    let secondsLeft = RECORDING_DURATION / 1000;
    const countdownDisplay = document.getElementById('recordingCountdown');
    countdownDisplay.textContent = `Recording ends in ${secondsLeft} seconds`;

    if (countdownInterval) clearInterval(countdownInterval);
    countdownInterval = setInterval(() => {
      secondsLeft--;
      countdownDisplay.textContent = `Recording ends in ${secondsLeft} seconds`;
    }, 1000);

    recordingTimeout = setTimeout(() => {
      stopRecording();
      clearInterval(countdownInterval);
    }, RECORDING_DURATION);
  }).catch(error => {
    statusDisplay.textContent = "Camera or mic access was denied.";
    console.error(error);
  });
}
